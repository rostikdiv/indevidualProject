package org.example.app_for_studing_java;

import javafx.scene.control.TextArea;

public class SetLectures {


    public static void setTextOfTopic_1(TextArea textArea){
        textArea.setText("Тема: Огляд мови програмування Java\n\n" +
                "Java — це високорівнева, об'єктно-орієнтована мова програмування, яка була розроблена компанією Sun Microsystems (тепер частина Oracle) в середині 1990-х років. Java створена для того, щоб бути простим у використанні, зручним для розробки та портативним для різних операційних систем і платформ. Основні характеристики Java:\n\n" +
                "1. Об'єктно-орієнтованість (OOP)\n\n" +
                "Java є об'єктно-орієнтованою мовою, що означає, що програмування здійснюється через створення класів і об'єктів. Кожна програма на Java організована навколо об'єктів, які взаємодіють між собою. Основні принципи ООП у Java:\n\n" +
                "* Інкапсуляція: приховування внутрішньої реалізації та надання доступу до даних через публічні методи.\n" +
                "* Наслідування: створення нових класів на основі існуючих, що дозволяє повторно використовувати код.\n" +
                "* Поліморфізм: здатність одного об'єкта виконувати різні операції в залежності від контексту.\n" +
                "* Абстракція: виділення суттєвих властивостей об'єкта, при цьому приховування деталей реалізації.\n\n" +
                "2. Платформонезалежність\n\n" +
                "Java розроблена для того, щоб програми, написані один раз, могли працювати на будь-якій платформі без необхідності переробляти код. Ця особливість забезпечується завдяки Java Virtual Machine (JVM), яка є посередником між програмою та операційною системою. Код Java компілюється в байт-код, який може виконуватись на будь-якій платформі, де є JVM.\n\n" +
                "3. Безпека\n\n" +
                "Java вважається однією з найбільш безпечних мов програмування завдяки своїй архітектурі, яка дозволяє виконувати код у 'пісочниці' (sandbox). Це означає, що програми Java мають обмежений доступ до системних ресурсів, що знижує ризик помилок і шкідливих дій.\n\n" +
                "4. Мультитредінг (Багатозадачність)\n\n" +
                "Java підтримує багатозадачність через потоки (threads). Кожен потік може виконувати частину програми незалежно від інших, що дозволяє ефективно використовувати ресурси багатоядерних процесорів та створювати більш швидкі й масштабовані програми.\n\n" +
                "5. Сучасні бібліотеки та фреймворки\n\n" +
                "Java має багатий набір стандартних бібліотек, що охоплюють різні аспекти програмування: обробка файлів, робота з базами даних, мережеві протоколи, графічний інтерфейс користувача, тощо. Крім того, для розробки великих та складних систем існують численні фреймворки, такі як Spring, Hibernate, JavaFX, які значно спрощують процес розробки.\n\n" +
                "6. Простота і чіткість синтаксису\n\n" +
                "Java має простий і зрозумілий синтаксис, що робить її відмінною мовою для навчання. Її синтаксис подібний до інших мов, таких як C та C++, що полегшує перехід до цих мов для програмістів.\n\n" +
                "7. Збірка сміття (Garbage Collection)\n\n" +
                "Java автоматично управляє пам'яттю через механізм збору сміття, що дозволяє програмісту не турбуватись про ручне очищення пам'яті, знижуючи ризик помилок, таких як витоки пам'яті.\n\n" +
                "8. Розповсюдження та використання\n\n" +
                "Java широко використовується для розробки веб-додатків (особливо через фреймворки, як Spring), мобільних додатків (особливо для Android), а також для створення серверних рішень та програм для великих підприємств.\n\n" +
                "Переваги Java:\n\n" +
                "* Платформонезалежність завдяки JVM.\n" +
                "* Багато стандартних бібліотек для роботи з мережею, графікою, базами даних.\n" +
                "* Потужний механізм обробки виключень для покращення стабільності програм.\n" +
                "* Велика спільнота розробників та активний розвиток.\n\n" +
                "Недоліки:\n\n" +
                "* Повільніше виконання порівняно з деякими іншими мовами, оскільки код має виконуватись через JVM.\n" +
                "* Використання пам'яті може бути більш затратним, оскільки Java використовує велику кількість ресурсів для управління об'єктами.\n\n" +
                "Ця мова програмування підходить для створення як невеликих додатків, так і великих корпоративних систем, завдяки своїй масштабованості, безпеці та стабільності.");
    }
    public static void setTextOfTopic_2(TextArea textArea){
        textArea.setText("Тема: Типи даних в Java\n\n" +
                "У Java існують два основні типи даних: **примітивні типи** (primitive types) і **об'єктні типи** (reference types).\n\n" +
                "1. Примітивні типи (Primitive Types)\n\n" +
                "Примітивні типи — це вбудовані типи даних, які не є об'єктами і зберігають значення безпосередньо в пам'яті.\n\n" +
                "Основні примітивні типи:\n\n" +
                "*   **byte**: 8 біт, значення від -128 до 127.\n" +
                "*   **short**: 16 біт, значення від -32,768 до 32,767.\n" +
                "*   **int**: 32 біт, значення від -2,147,483,648 до 2,147,483,647.\n" +
                "*   **long**: 64 біт, значення від -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.\n" +
                "*   **float**: 32 біт, використовується для представлення чисел з плаваючою комою (точність до 7 знаків після коми).\n" +
                "*   **double**: 64 біт, використовується для представлення чисел з плаваючою комою (точність до 15 знаків після коми).\n" +
                "*   **char**: 16 біт, представляє один символ Unicode (наприклад, 'A', '1').\n" +
                "*   **boolean**: зберігає одне з двох значень: `true` або `false`.\n\n" +
                "2. Об'єктні типи (Reference Types)\n\n" +
                "Об'єктні типи зберігають посилання на об'єкти, а не самі значення. До об'єктних типів належать всі класи, інтерфейси та масиви.\n\n" +
                "Основні об'єктні типи:\n\n" +
                "*   **String**: клас, який представляє рядки тексту.\n" +
                "*   **Масиви**: структура даних, що дозволяє зберігати множину елементів одного типу.\n" +
                "*   **Класи та об'єкти**: об'єктні типи, створені за допомогою класів. Вони дозволяють створювати складніші структури даних та включають в себе змінні і методи.\n\n" +
                "3. Автоматичне перетворення (Autoboxing) і розпакування (Unboxing)\n\n" +
                "У Java існує концепція автоматичного перетворення між примітивними типами і їх обгортками (wrapper classes).\n\n" +
                "*   Автоматичне перетворення примітивного типу в обгортку:\n" +
                "    `int num = 10; Integer boxedNum = num; // Автоматичне перетворення в Integer`\n\n" +
                "*   Розпакування (перетворення з обгортки в примітив):\n" +
                "    `Integer boxedNum = 10; int num = boxedNum; // Автоматичне розпакування в int`\n\n" +
                "4. Значення за замовчуванням\n\n" +
                "Якщо змінну не ініціалізовано, вона отримує значення за замовчуванням:\n\n" +
                "*   Для **примітивних типів**:\n" +
                "    *   `int`, `short`, `byte`, `long` — 0\n" +
                "    *   `float`, `double` — 0.0\n" +
                "    *   `char` — '\\u0000' (пустий символ)\n" +
                "    *   `boolean` — `false`\n" +
                "*   Для **об'єктних типів**: `null`.\n\n" +
                "5. Типи даних у масивах\n\n" +
                "Масиви в Java можуть зберігати елементи будь-якого типу (як примітивного, так і об'єктного). Масиви — це об'єктні типи, і вони зберігають посилання на свої елементи.\n\n" +
                "Приклад:\n" +
                "`int[] numbers = {1, 2, 3, 4}; // Масив цілих чисел`\n" +
                "`String[] words = {\"hello\", \"world\"}; // Масив рядків`\n\n" +
                "Підсумок:\n\n" +
                "Розуміння типів даних є важливим кроком у вивченні Java, оскільки правильний вибір типу даних допомагає зекономити пам'ять і підвищити ефективність програм. Примітивні типи використовуються для простих значень, а об'єктні — для складніших структур даних, таких як рядки, масиви та класи.");
    }
    public static void setTextOfTopic_3(TextArea textArea){
        textArea.setText("Тема: Змінні, оператори та вирази в Java\n\n" +
                "1. Змінні в Java\n\n" +
                "Змінна в Java — це ім'я, яке представляє певне місце в пам'яті, де зберігається значення певного типу. Для оголошення змінної потрібно вказати її тип і ім'я.\n\n" +
                "Оголошення змінної:\n\n" +
                "`тип_даних ім'я_змінної;`\n\n" +
                "Приклад:\n\n" +
                "`int age; // Оголошення змінної типу int`\n" +
                "`age = 25; // Присвоєння значення змінній`\n\n" +
                "Змінні можна ініціалізувати під час оголошення:\n\n" +
                "`int age = 25; // Оголошення та ініціалізація змінної одночасно`\n\n" +
                "2. Типи змінних\n\n" +
                "В Java є два основних типи змінних:\n\n" +
                "*   **Примітивні типи** (int, boolean, double тощо).\n" +
                "*   **Об'єктні типи** (String, масиви, класи).\n\n" +
                "3. Оператори в Java\n\n" +
                "Оператори використовуються для виконання операцій над змінними та значеннями.\n\n" +
                "Основні категорії операторів:\n\n" +
                "*   **Арифметичні оператори**:\n" +
                "    *   `+` — додавання\n" +
                "    *   `-` — віднімання\n" +
                "    *   `*` — множення\n" +
                "    *   `/` — ділення\n" +
                "    *   `%` — залишок від ділення\n\n" +
                "    Приклад:\n\n" +
                "    `int a = 10, b = 5;`\n" +
                "    `int sum = a + b; // sum = 15`\n" +
                "    `int remainder = a % b; // remainder = 0`\n\n" +
                "*   **Оператори порівняння**:\n" +
                "    *   `==` — рівність\n" +
                "    *   `!=` — нерівність\n" +
                "    *   `>` — більше\n" +
                "    *   `<` — менше\n" +
                "    *   `>=` — більше або рівно\n" +
                "    *   `<=` — менше або рівно\n\n" +
                "    Приклад:\n\n" +
                "    `int x = 10, y = 20;`\n" +
                "    `boolean result = x < y; // result = true`\n\n" +
                "*   **Логічні оператори**:\n" +
                "    *   `&&` — логічне \"і\"\n" +
                "    *   `||` — логічне \"або\"\n" +
                "    *   `!` — логічне \"не\"\n\n" +
                "    Приклад:\n\n" +
                "    `boolean a = true, b = false;`\n" +
                "    `boolean result = a && b; // result = false`\n\n" +
                "*   **Присвоєння**:\n" +
                "    *   `=` — оператор присвоєння\n" +
                "    *   `+=`, `-=`, `*=`, `/=` — комбіновані оператори присвоєння\n\n" +
                "    Приклад:\n\n" +
                "    `int a = 10;`\n" +
                "    `a += 5; // a = 15`\n\n" +
                "4. Вирази в Java\n\n" +
                "Вираз — це будь-яка комбінація змінних, значень та операторів, що дає результат. Вираз може бути простим або складним.\n\n" +
                "Приклад простого виразу:\n\n" +
                "`int a = 5 + 3; // Вираз, який дає результат 8`\n\n" +
                "Складений вираз:\n\n" +
                "`int a = 10, b = 5;`\n" +
                "`int result = (a + b) * 2; // Вираз з дужками, який дає результат 30`\n\n" +
                "5. Оператори інкремента та декремента\n\n" +
                "Оператори `++` і `--` використовуються для збільшення або зменшення значення змінної на 1.\n\n" +
                "Приклад:\n\n" +
                "`int a = 5;`\n" +
                "`a++; // a = 6`\n" +
                "`a--; // a = 5`\n\n" +
                "6. Типи присвоєнь\n\n" +
                "*   **Пряме присвоєння**:\n\n" +
                "` = 10;`\n\n" +
                "*   **Присвоєння через інкремент**:\n\n" +
                "`x++; // Збільшення на 1`\n\n" +
                "7. Важливі аспекти:\n\n" +
                "*   У Java змінні мають певні типи, і операції з ними обмежені правилами типізації.\n" +
                "*   Оператори виконуються з певним пріоритетом, що визначає порядок їх виконання в складних виразах.\n\n" +
                "Підсумок:\n\n" +
                "Розуміння змінних, операторів і виразів є основою для написання програм на Java. Змінні використовуються для зберігання значень, оператори для виконання операцій над ними, а вирази обчислюють результат.");
    }
    public static void setTextOfTopic_4(TextArea textArea){
        textArea.setText("Тема: Основні структури програм (цикли, умовні оператори)\n\n" +
                "1. Умовні оператори в Java\n\n" +
                "Умовні оператори дозволяють виконувати певні дії в залежності від того, чи виконується умова. Вони використовуються для вибору різних шляхів виконання програми в залежності від результату перевірки умови.\n\n" +
                "- **if** — використовується для виконання блоку коду, якщо умова істинна.\n" +
                "```java\n" +
                "if (умова) {\n" +
                "    // Код виконується, якщо умова істинна\n" +
                "}\n" +
                "```\n" +
                "Приклад:\n" +
                "```java\n" +
                "int age = 18;\n" +
                "if (age >= 18) {\n" +
                "    System.out.println(\"Дорослий\");\n" +
                "}\n" +
                "```\n\n" +
                "- **if-else** — дозволяє виконати один блок коду, якщо умова істинна, і інший блок, якщо умова хибна.\n" +
                "```java\n" +
                "if (умова) {\n" +
                "    // Код, якщо умова істинна\n" +
                "} else {\n" +
                "    // Код, якщо умова хибна\n" +
                "}\n" +
                "```\n" +
                "Приклад:\n" +
                "```java\n" +
                "int age = 16;\n" +
                "if (age >= 18) {\n" +
                "    System.out.println(\"Дорослий\");\n" +
                "} else {\n" +
                "    System.out.println(\"Неповнолітній\");\n" +
                "}\n" +
                "```\n\n" +
                "- **else-if** — використовується для перевірки кількох умов.\n" +
                "```java\n" +
                "if (умова1) {\n" +
                "    // Код, якщо умова1 істинна\n" +
                "} else if (умова2) {\n" +
                "    // Код, якщо умова2 істинна\n" +
                "} else {\n" +
                "    // Код, якщо жодна з умов не істинна\n" +
                "}\n" +
                "```\n" +
                "Приклад:\n" +
                "```java\n" +
                "int number = 10;\n" +
                "if (number > 0) {\n" +
                "    System.out.println(\"Позитивне число\");\n" +
                "} else if (number < 0) {\n" +
                "    System.out.println(\"Негативне число\");\n" +
                "} else {\n" +
                "    System.out.println(\"Нуль\");\n" +
                "}\n" +
                "```\n\n" +
                "- **switch** — використовується для перевірки множинних варіантів значення змінної.\n" +
                "```java\n" +
                "switch (значення) {\n" +
                "    case варіант1:\n" +
                "        // Код, якщо значення дорівнює варіант1\n" +
                "        break;\n" +
                "    case варіант2:\n" +
                "        // Код, якщо значення дорівнює варіант2\n" +
                "        break;\n" +
                "    default:\n" +
                "        // Код, якщо значення не дорівнює жодному з варіантів\n" +
                "}\n" +
                "```\n" +
                "Приклад:\n" +
                "```java\n" +
                "int day = 3;\n" +
                "switch (day) {\n" +
                "    case 1:\n" +
                "        System.out.println(\"Понеділок\");\n" +
                "        break;\n" +
                "    case 2:\n" +
                "        System.out.println(\"Вівторок\");\n" +
                "        break;\n" +
                "    case 3:\n" +
                "        System.out.println(\"Середа\");\n" +
                "        break;\n" +
                "    default:\n" +
                "        System.out.println(\"Невірний день\");\n" +
                "}\n" +
                "```\n\n" +
                "2. Цикли в Java\n\n" +
                "Цикли дозволяють повторювати певний блок коду кілька разів, поки виконується певна умова.\n\n" +
                "- **for** — використовується для виконання циклу певну кількість разів.\n" +
                "```java\n" +
                "for (ініціалізація; умова; інкремент/де Krement) {\n" +
                "    // Код, що повторюється\n" +
                "}\n" +
                "```\n" +
                "Приклад:\n" +
                "```java\n" +
                "for (int i = 0; i < 5; i++) {\n" +
                "    System.out.println(\"Номер: \" + i);\n" +
                "}\n" +
                "```\n\n" +
                "- **while** — цикл, який виконується, поки умова істинна.\n" +
                "```java\n" +
                "while (умова) {\n" +
                "    // Код, що повторюється\n" +
                "}\n" +
                "```\n" +
                "Приклад:\n" +
                "```java\n" +
                "int i = 0;\n" +
                "while (i < 5) {\n" +
                "    System.out.println(\"Номер: \" + i);\n" +
                "    i++;\n" +
                "}\n" +
                "```\n\n" +
                "- **do-while** — подібний до циклу `while`, але перевірка умови відбувається після виконання коду, тому хоча б один цикл виконується обов'язково.\n" +
                "```java\n" +
                "do {\n" +
                "    // Код, що повторюється\n" +
                "} while (умова);\n" +
                "```\n" +
                "Приклад:\n" +
                "```java\n" +
                "int i = 0;\n" +
                "do {\n" +
                "    System.out.println(\"Номер: \" + i);\n" +
                "    i++;\n" +
                "} while (i < 5);\n" +
                "```\n\n" +
                "3. Важливі аспекти:\n\n" +
                "- **Break** — використовується для негайного виходу з циклу або умовного оператора.\n" +
                "```java\n" +
                "for (int i = 0; i < 10; i++) {\n" +
                "    if (i == 5) {\n" +
                "        break; // Вихід з циклу, якщо i дорівнює 5\n" +
                "    }\n" +
                "    System.out.println(i);\n" +
                "}\n" +
                "```\n\n" +
                "- **Continue** — пропускає поточну ітерацію циклу та переходить до наступної.\n" +
                "```java\n" +
                "for (int i = 0; i < 10; i++) {\n" +
                "    if (i == 5) {\n" +
                "        continue; // Пропуск ітерації, якщо i дорівнює 5\n" +
                "    }\n" +
                "    System.out.println(i);\n" +
                "}\n" +
                "```\n\n" +
                "Підсумок:\n\n" +
                "Умовні оператори та цикли є основними інструментами для керування потоком виконання програми в Java. Вони дозволяють програмі адаптуватися до різних ситуацій і повторювати дії в залежності від заданих умов, що є основою для розробки логіки програми.");
    }
    public static void setTextOfTopic_5(TextArea textArea){
        textArea.setText("Тема: Класи та об'єкти в Java\n\n" +
                "1. Що таке клас?\n\n" +
                "У Java клас — це шаблон для створення об'єктів. Клас визначає властивості (поля) і методи, які будуть доступні для об'єктів, створених на його основі. Клас можна розглядати як блакитну принт для об'єктів.\n\n" +
                "* **Поля (Attributes)** — це змінні, які зберігають стан об'єкта.\n" +
                "* **Методи (Methods)** — це функції, які визначають поведінку об'єкта.\n\n" +
                "2. Що таке об'єкт?\n\n" +
                "Об'єкт — це конкретний екземпляр класу, який має свої значення полів. Об'єкти створюються за допомогою конструктора класу.\n\n" +
                "```java\n" +
                "public class Car {\n" +
                "    // Поля класу\n" +
                "    String color;\n" +
                "    String model;\n\n" +
                "    // Метод класу\n" +
                "    public void drive() {\n" +
                "        System.out.println(\"Машина їде.\");\n" +
                "    }\n\n" +
                "    public static void main(String[] args) {\n" +
                "        // Створення об'єкта\n" +
                "        Car myCar = new Car();\n" +
                "        myCar.color = \"Червоний\";\n" +
                "        myCar.model = \"BMW\";\n\n" +
                "        System.out.println(\"Модель: \" + myCar.model);\n" +
                "        System.out.println(\"Колір: \" + myCar.color);\n\n" +
                "        myCar.drive();  // Виклик методу об'єкта\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "3. Структура класу\n\n" +
                "```java\n" +
                "public class ClassName {\n" +
                "    // Поля (Атрибути)\n" +
                "    private String name;\n" +
                "    private int age;\n\n" +
                "    // Конструктор\n" +
                "    public ClassName(String name, int age) {\n" +
                "        this.name = name;\n" +
                "        this.age = age;\n" +
                "    }\n\n" +
                "    // Метод\n" +
                "    public void greet() {\n" +
                "        System.out.println(\"Привіт, мене звати \" + name + \" і мені \" + age + \" років.\");\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "4. Конструктори\n\n" +
                "Конструктор — це спеціальний метод, який викликається при створенні нового об'єкта класу. Він має таку ж назву, як і клас, і не має типу повернення.\n\n" +
                "```java\n" +
                "public class Person {\n" +
                "    String name;\n\n" +
                "    // Конструктор\n" +
                "    public Person(String name) {\n" +
                "        this.name = name;\n" +
                "    }\n\n" +
                "    public void introduce() {\n" +
                "        System.out.println(\"Привіт, мене звати \" + name);\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "5. Інкапсуляція\n\n" +
                "Інкапсуляція — це принцип ООП, що дозволяє приховати внутрішню реалізацію класу від зовнішнього світу і надавати доступ до його полів лише через методи.\n\n" +
                "* Використання **private** для полів класу дозволяє захистити їх від безпосереднього доступу.\n" +
                "* Для доступу до полів використовуються методи **get** і **set**.\n\n" +
                "```java\n" +
                "public class Person {\n" +
                "    private String name;\n\n" +
                "    // Getters і Setters\n" +
                "    public String getName() {\n" +
                "        return name;\n" +
                "    }\n\n" +
                "    public void setName(String name) {\n" +
                "        this.name = name;\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "6. Статичні (static) методи та поля\n\n" +
                "Статичні поля і методи належать класу, а не його екземплярам. Тобто до статичних полів і методів можна звертатися без створення об'єкта класу.\n\n" +
                "```java\n" +
                "public class Counter {\n" +
                "    private static int count = 0;\n\n" +
                "    public static void increment() {\n" +
                "        count++;\n" +
                "    }\n\n" +
                "    public static int getCount() {\n" +
                "        return count;\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "Приклад використання:\n\n" +
                "```java\n" +
                "Counter.increment();\n" +
                "System.out.println(Counter.getCount());  // Виведе 1\n" +
                "```\n\n" +
                "7. Підсумок\n\n" +
                "Класи і об'єкти є основними концепціями об'єктно-орієнтованого програмування (ООП). Клас визначає шаблон для створення об'єктів, а об'єкти — це конкретні екземпляри класу з власними значеннями. За допомогою класів можна організувати і структурувати код, застосовуючи принципи інкапсуляції, успадкування та поліморфізму.");
    }
    public static void setTextOfTopic_6(TextArea textArea){
        textArea.setText("Тема: Інкапсуляція в Java\n\n" +
                "1. Що таке інкапсуляція?\n\n" +
                "Інкапсуляція — це один з основних принципів об'єктно-орієнтованого програмування (ООП), " +
                "який полягає в тому, щоб приховати внутрішню реалізацію об'єкта і надавати доступ до його даних " +
                "тільки через визначені методи. Це дозволяє забезпечити більшу безпеку та контроль за станом об'єкта, " +
                "обмежуючи доступ до його полів.\n\n" +
                "2. Принципи інкапсуляції\n\n" +
                "Інкапсуляція дозволяє:\n\n" +
                "*   Приховати внутрішні деталі реалізації класу.\n" +
                "*   Дати змогу взаємодіяти з класом тільки через публічні методи (getter та setter).\n" +
                "*   Забезпечити контроль за змінами значень полів.\n\n" +
                "3. Як реалізується інкапсуляція?\n\n" +
                "Інкапсуляція в Java реалізується за допомогою:\n\n" +
                "*   **Модифікаторів доступу** (`private`, `public`, `protected`, `default`), які визначають рівень доступу до полів та методів.\n" +
                "*   **Методів getter і setter**, через які забезпечується доступ до приватних полів класу.\n\n" +
                "4. Приклад інкапсуляції\n\n" +
                "```java\n" +
                "public class Person {\n" +
                "    // Приватне поле\n" +
                "    private String name;\n" +
                "    private int age;\n\n" +
                "    // Конструктор для ініціалізації полів\n" +
                "    public Person(String name, int age) {\n" +
                "        this.name = name;\n" +
                "        this.age = age;\n" +
                "    }\n\n" +
                "    // Getter для поля name\n" +
                "    public String getName() {\n" +
                "        return name;\n" +
                "    }\n\n" +
                "    // Setter для поля name\n" +
                "    public void setName(String name) {\n" +
                "        this.name = name;\n" +
                "    }\n\n" +
                "    // Getter для поля age\n" +
                "    public int getAge() {\n" +
                "        return age;\n" +
                "    }\n\n" +
                "    // Setter для поля age\n" +
                "    public void setAge(int age) {\n" +
                "        if (age >= 0) {  // Перевірка на коректність\n" +
                "            this.age = age;\n" +
                "        }\n" +
                "    }\n\n" +
                "    // Метод для виведення інформації\n" +
                "    public void introduce() {\n" +
                "        System.out.println(\"Привіт, мене звати \" + name + \" і мені \" + age + \" років.\");\n" +
                "    }\n" +
                "}\n\n" +
                "public class Main {\n" +
                "    public static void main(String[] args) {\n" +
                "        // Створення об'єкта класу Person\n" +
                "        Person person = new Person(\"Іван\", 25);\n\n" +
                "        // Виведення інформації через метод\n" +
                "        person.introduce();\n\n" +
                "        // Зміна віку через setter\n" +
                "        person.setAge(30);\n\n" +
                "        // Виведення оновленої інформації\n" +
                "        System.out.println(\"Нове значення віку: \" + person.getAge());\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "5. Переваги інкапсуляції\n\n" +
                "*   **Безпека**: Зберігаються лише необхідні дані, а доступ до них контролюється.\n" +
                "*   **Захист від некоректних змін**: Через setter можна додавати перевірки, щоб значення полів були валідними.\n" +
                "*   **Простота в обслуговуванні**: Логіку перевірок та змін можна змінювати, не впливаючи на інші частини програми.\n\n" +
                "6. Підсумок\n\n" +
                "Інкапсуляція дозволяє створювати більш надійні, гнучкі та безпечні програми, " +
                "приховуючи реалізаційні деталі класу та надаючи доступ до важливих даних лише через контрольовані методи.");
    }
    public static void setTextOfTopic_7(TextArea textArea){
        textArea.setText("Тема: Наслідування в Java\n\n" +
                "1. Що таке наслідування?\n\n" +
                "Наслідування — це принцип об'єктно-орієнтованого програмування (ООП), " +
                "який дозволяє створювати нові класи на основі існуючих. Це дозволяє зберігати загальні характеристики в батьківському класі, " +
                "а в дочірніх класах додавати або змінювати ці характеристики.\n\n" +
                "2. Основи наслідування\n\n" +
                "У Java наслідування реалізується за допомогою ключового слова `extends`. Клас, який наслідується, називається **батьківським** (або **суперкласом**), а клас, що успадковує властивості та методи, називається **дочірнім** (або **підкласом**).\n\n" +
                "3. Як працює наслідування?\n\n" +
                "*   Дочірній клас успадковує всі публічні та захищені (protected) методи та поля батьківського класу.\n" +
                "*   Дочірній клас може додавати свої методи та поля.\n" +
                "*   Дочірній клас може перекривати методи батьківського класу за допомогою ключового слова `@Override`.\n" +
                "*   Батьківський клас може викликати методи дочірнього класу через об'єкти цього класу.\n\n" +
                "4. Приклад наслідування\n\n" +
                "```java\n" +
                "// Батьківський клас (Суперклас)\n" +
                "public class Animal {\n" +
                "    // Поле\n" +
                "    private String name;\n\n" +
                "    // Конструктор\n" +
                "    public Animal(String name) {\n" +
                "        this.name = name;\n" +
                "    }\n\n" +
                "    // Метод\n" +
                "    public void makeSound() {\n" +
                "        System.out.println(\"Тварина робить звук\");\n" +
                "    }\n\n" +
                "    // Getter\n" +
                "    public String getName() {\n" +
                "        return name;\n" +
                "    }\n" +
                "}\n\n" +
                "// Дочірній клас (Підклас)\n" +
                "public class Dog extends Animal {\n\n" +
                "    // Конструктор\n" +
                "    public Dog(String name) {\n" +
                "        super(name);  // Викликаємо конструктор батьківського класу\n" +
                "    }\n\n" +
                "    // Перекриття методу makeSound\n" +
                "    @Override\n" +
                "    public void makeSound() {\n" +
                "        System.out.println(\"Собака гавкає\");\n" +
                "    }\n" +
                "}\n\n" +
                "public class Main {\n" +
                "    public static void main(String[] args) {\n" +
                "        // Створення об'єкта класу Dog\n" +
                "        Animal myDog = new Dog(\"Шерлок\");\n\n" +
                "        // Виклик методу makeSound через об'єкт дочірнього класу\n" +
                "        myDog.makeSound();  // Виведе: \"Собака гавкає\"\n\n" +
                "        // Виклик методу getName\n" +
                "        System.out.println(myDog.getName());  // Виведе: \"Шерлок\"\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "5. Переваги наслідування\n\n" +
                "*   **Повторне використання коду**: Можливість використовувати методи та властивості батьківського класу без необхідності їх переписування.\n" +
                "*   **Гнучкість**: Дочірні класи можуть додавати або змінювати функціональність батьківських класів.\n" +
                "*   **Полегшення підтримки**: Спільна логіка в батьківському класі дозволяє змінювати код лише в одному місці.\n\n" +
                "6. Обмеження наслідування\n\n" +
                "*   **Одинарне наслідування**: Java підтримує тільки один клас як батьківський (на відміну від багатокласного наслідування в деяких інших мовах).\n" +
                "*   **Втрата гнучкості**: Якщо структура класів стає занадто складною, це може ускладнити підтримку та розширення програми.\n\n" +
                "7. Підсумок\n\n" +
                "Наслідування дозволяє створювати класи, які успадковують властивості та методи від інших класів, що спрощує розробку програм та забезпечує повторне використання коду. Але потрібно використовувати це з обережністю, щоб уникнути надмірного ускладнення структури класів.");

    }
    public static void setTextOfTopic_8(TextArea textArea){
        textArea.setText("Тема: Поліморфізм\n\n" +
                "1. Що таке поліморфізм?\n\n" +
                "Поліморфізм — це один з основних принципів об'єктно-орієнтованого програмування, " +
                "який дозволяє об'єктам різних класів реагувати на однакові повідомлення (виклик методів) по-різному. " +
                "Поліморфізм дає змогу використовувати однаковий інтерфейс для роботи з об'єктами різних типів, що підвищує гнучкість і розширюваність програм.\n\n" +
                "2. Типи поліморфізму\n\n" +
                "Існують два основних типи поліморфізму:\n\n" +
                "* Поліморфізм часу компіляції (методний поліморфізм або перевантаження методів): Це дозволяє визначати кілька методів з однаковим ім'ям, але з різними параметрами. Виклик конкретного методу залежить від типу та кількості переданих аргументів.\n\n" +
                "* Поліморфізм часу виконання (динамічний поліморфізм або перевизначення методів): Це дозволяє під час виконання програми викликати методи з однаковими іменами у різних класах. Вибір методу, який має бути викликаний, визначається типом об'єкта, з яким працює програма, а не типом змінної.\n\n" +
                "3. Приклад поліморфізму часу компіляції\n\n" +
                "Перевантаження методів (методний поліморфізм):\n\n" +
                "class Calculator {\n" +
                "    // Метод для додавання двох цілих чисел\n" +
                "    public int add(int a, int b) {\n" +
                "        return a + b;\n" +
                "    }\n\n" +
                "    // Метод для додавання трьох цілих чисел\n" +
                "    public int add(int a, int b, int c) {\n" +
                "        return a + b + c;\n" +
                "    }\n\n" +
                "    // Метод для додавання двох чисел з плаваючою комою\n" +
                "    public double add(double a, double b) {\n" +
                "        return a + b;\n" +
                "    }\n" +
                "}\n\n" +
                "public class Main {\n" +
                "    public static void main(String[] args) {\n" +
                "        Calculator calculator = new Calculator();\n" +
                "        System.out.println(calculator.add(2, 3));         // Викликається перший метод\n" +
                "        System.out.println(calculator.add(2, 3, 4));      // Викликається другий метод\n" +
                "        System.out.println(calculator.add(2.5, 3.7));     // Викликається третій метод\n" +
                "    }\n" +
                "}\n\n" +
                "4. Приклад поліморфізму часу виконання\n\n" +
                "Перевизначення методів (динамічний поліморфізм):\n\n" +
                "class Animal {\n" +
                "    public void makeSound() {\n" +
                "        System.out.println(\"Animal makes a sound\");\n" +
                "    }\n" +
                "}\n\n" +
                "class Dog extends Animal {\n" +
                "    @Override\n" +
                "    public void makeSound() {\n" +
                "        System.out.println(\"Dog barks\");\n" +
                "    }\n" +
                "}\n\n" +
                "class Cat extends Animal {\n" +
                "    @Override\n" +
                "    public void makeSound() {\n" +
                "        System.out.println(\"Cat meows\");\n" +
                "    }\n" +
                "}\n\n" +
                "public class Main {\n" +
                "    public static void main(String[] args) {\n" +
                "        Animal animal1 = new Dog();\n" +
                "        Animal animal2 = new Cat();\n\n" +
                "        animal1.makeSound();  // Виведе: Dog barks\n" +
                "        animal2.makeSound();  // Виведе: Cat meows\n" +
                "    }\n" +
                "}\n\n" +
                "5. Переваги поліморфізму\n\n" +
                "* Забезпечує гнучкість і масштабованість: Оскільки можна працювати з різними типами об'єктів, використовуючи один і той самий інтерфейс (наприклад, один метод).\n" +
                "* Підвищує зручність коду: Дає змогу використовувати одні й ті самі імена методів для виконання різних операцій, зберігаючи при цьому чистоту і зручність коду.\n" +
                "* Зменшує зв'язність коду: Клас, який працює з іншими класами, не обов'язково має знати їхні конкретні типи, що дозволяє змінювати реалізації без зміни коду, що їх використовує.\n\n" +
                "6. Підсумок\n\n" +
                "Поліморфізм — це один із базових принципів об'єктно-орієнтованого програмування, " +
                "який дозволяє програмам бути гнучкими, масштабованими і легкими для розширення. " +
                "Він підтримує як перевантаження методів (поліморфізм часу компіляції), так і перевизначення методів (поліморфізм часу виконання).");

    }
    public static void setTextOfTopic_9(TextArea textArea){
        textArea.setText("Тема: Абстракція в Java\n\n" +
                "1. Що таке абстракція?\n\n" +
                "Абстракція — це принцип об'єктно-орієнтованого програмування (ООП), який дозволяє приховати складні деталі реалізації та зосередитись на суті. Це означає, що користувач може взаємодіяти з об'єктами, не замислюючись про їх внутрішню реалізацію. Абстракція дозволяє виділяти тільки важливі аспекти, спрощуючи розуміння системи.\n\n" +
                "2. Як працює абстракція в Java?\n\n" +
                "У Java абстракція досягається за допомогою:\n" +
                "*   **Абстрактних класів**: класів, які не можна інстанціювати, але вони можуть мати абстрактні методи, що повинні бути реалізовані в підкласах.\n" +
                "*   **Інтерфейсів**: вони задають контракти, які повинні бути реалізовані класами, що їх використовують, але самі не можуть містити реалізацій методів (до Java 8).\n\n" +
                "3. Абстрактні класи\n\n" +
                "Абстрактні класи можуть містити як абстрактні методи (методи без реалізації), так і звичайні методи з реалізацією. Абстрактні методи повинні бути реалізовані в дочірніх класах.\n\n" +
                "4. Приклад абстракції з абстрактним класом\n\n" +
                "```java\n" +
                "// Абстрактний клас\n" +
                "public abstract class Animal {\n" +
                "    // Поле\n" +
                "    private String name;\n\n" +
                "    // Конструктор\n" +
                "    public Animal(String name) {\n" +
                "        this.name = name;\n" +
                "    }\n\n" +
                "    // Абстрактний метод\n" +
                "    public abstract void makeSound();\n\n" +
                "    // Getter для імені\n" +
                "    public String getName() {\n" +
                "        return name;\n" +
                "    }\n" +
                "}\n\n" +
                "// Дочірній клас\n" +
                "public class Dog extends Animal {\n\n" +
                "    // Конструктор\n" +
                "    public Dog(String name) {\n" +
                "        super(name);\n" +
                "    }\n\n" +
                "    // Реалізація абстрактного методу\n" +
                "    @Override\n" +
                "    public void makeSound() {\n" +
                "        System.out.println(\"Гав гав!\");\n" +
                "    }\n" +
                "}\n\n" +
                "public class Main {\n" +
                "    public static void main(String[] args) {\n" +
                "        Animal myDog = new Dog(\"Шерлок\");\n" +
                "        myDog.makeSound();  // Виведе: \"Гав гав!\"\n" +
                "        System.out.println(myDog.getName());  // Виведе: \"Шерлок\"\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "5. Інтерфейси\n\n" +
                "Інтерфейси дозволяють визначати контракт, який клас повинен виконувати. У Java інтерфейс може містити тільки оголошення методів, а клас, який реалізує цей інтерфейс, повинен забезпечити їх реалізацію.\n\n" +
                "6. Приклад абстракції з інтерфейсом\n\n" +
                "```java\n" +
                "// Інтерфейс\n" +
                "public interface Animal {\n" +
                "    void makeSound();\n" +
                "}\n\n" +
                "// Клас, що реалізує інтерфейс\n" +
                "public class Dog implements Animal {\n" +
                "    @Override\n" +
                "    public void makeSound() {\n" +
                "        System.out.println(\"Гав гав!\");\n" +
                "    }\n" +
                "}\n\n" +
                "public class Main {\n" +
                "    public static void main(String[] args) {\n" +
                "        Animal myDog = new Dog();\n" +
                "        myDog.makeSound();  // Виведе: \"Гав гав!\"\n" +
                "    }\n" +
                "}\n" +
                "```\n\n" +
                "7. Переваги абстракції\n\n" +
                "*   **Спрощення коду**: приховування складних деталей реалізації робить програму більш зрозумілою.\n" +
                "*   **Гнучкість і масштабованість**: абстракція дозволяє змінювати внутрішню реалізацію без впливу на зовнішній інтерфейс.\n" +
                "*   **Покращення підтримки та тестування**: надається чітке визначення, які методи повинні бути реалізовані класами, що реалізують інтерфейси або абстрактні класи.\n\n" +
                "8. Підсумок\n\n" +
                "Абстракція в Java дозволяє зменшити складність програм, приховуючи деталі реалізації та фокусуючись лише на необхідній інформації. Це досягається через абстрактні класи та інтерфейси, що дозволяють створювати гнучкі та зручні в підтримці прогр");
    }
    public static void setTextOfTopic_10(TextArea textArea){
        textArea.setText("Тема: Списки, множини, карти (List, Set, Map)\n\n" +
                "1. Що таке колекції в Java?\n" +
                "Колекції в Java — це об'єкти, які дозволяють зберігати та обробляти групи елементів. Вони є частиною Java Collections Framework і включають такі структури даних, як списки, множини та карти. Кожен з цих типів колекцій має свої особливості і застосування.\n\n" +
                "2. Списки (List)\n" +
                "`List` — це колекція, яка дозволяє зберігати елементи в порядку їх додавання, з можливістю доступу за індексом. Списки можуть містити дублікати елементів.\n\n" +
                "  * Особливості:\n" +
                "    * Доступ до елементів через індекс.\n" +
                "    * Порядок елементів зберігається.\n" +
                "    * Підтримка дублікатів.\n\n" +
                "  * Приклад використання:\n" +
                "    import java.util.ArrayList;\n" +
                "    import java.util.List;\n\n" +
                "    public class ListExample {\n" +
                "        public static void main(String[] args) {\n" +
                "            List<String> list = new ArrayList<>();\n" +
                "            list.add(\"Java\");\n" +
                "            list.add(\"Python\");\n" +
                "            list.add(\"C++\");\n\n" +
                "            // Доступ до елемента за індексом\n" +
                "            System.out.println(list.get(1));  // Виведе: Python\n\n" +
                "            // Виведення всіх елементів\n" +
                "            for (String language : list) {\n" +
                "                System.out.println(language);\n" +
                "            }\n" +
                "        }\n" +
                "    }\n\n" +
                "3. Множини (Set)\n" +
                "`Set` — це колекція, яка не дозволяє дублювання елементів. Множини зберігають тільки унікальні значення і не гарантують порядок елементів.\n\n" +
                "  * Особливості:\n" +
                "    * Не підтримують дублікати.\n" +
                "    * Порядок елементів не гарантовано (окрім конкретних реалізацій, таких як `LinkedHashSet`).\n\n" +
                "  * Приклад використання:\n" +
                "    import java.util.HashSet;\n" +
                "    import java.util.Set;\n\n" +
                "    public class SetExample {\n" +
                "        public static void main(String[] args) {\n" +
                "            Set<String> set = new HashSet<>();\n" +
                "            set.add(\"Java\");\n" +
                "            set.add(\"Python\");\n" +
                "            set.add(\"Java\");  // Дублікати ігноруються\n\n" +
                "            // Виведення всіх елементів\n" +
                "            for (String language : set) {\n" +
                "                System.out.println(language);\n" +
                "            }\n" +
                "        }\n" +
                "    }\n\n" +
                "4. Карти (Map)\n" +
                "`Map` — це колекція, яка зберігає пари \"ключ-значення\". Кожен ключ є унікальним, але значення можуть повторюватися. Карти дозволяють ефективно шукати значення за ключем.\n\n" +
                "  * Особливості:\n" +
                "    * Кожен елемент складається з пари \"ключ-значення\".\n" +
                "    * Ключі унікальні, але значення можуть бути однаковими.\n" +
                "    * Підтримка швидкого пошуку за ключем.\n\n" +
                "  * Приклад використання:\n" +
                "    import java.util.HashMap;\n" +
                "    import java.util.Map;\n\n" +
                "    public class MapExample {\n" +
                "        public static void main(String[] args) {\n" +
                "            Map<String, Integer> map = new HashMap<>();\n" +
                "            map.put(\"Java\", 1995);\n" +
                "            map.put(\"Python\", 1991);\n" +
                "            map.put(\"C++\", 1985);\n\n" +
                "            // Виведення значення за ключем\n" +
                "            System.out.println(\"Рік створення Java: \" + map.get(\"Java\"));\n\n" +
                "            // Виведення всіх елементів\n" +
                "            for (Map.Entry<String, Integer> entry : map.entrySet()) {\n" +
                "                System.out.println(entry.getKey() + \" був створений в \" + entry.getValue());\n" +
                "            }\n" +
                "        }\n" +
                "    }\n\n" +
                "5. Порівняння List, Set, Map\n" +
                "| Характеристика          | List                        | Set                         | Map                            |\n" +
                "|-------------------------|-----------------------------|-----------------------------|---------------------------------|\n" +
                "| Дублікат елементів       | Підтримує                   | Не підтримує                | Ключі повинні бути унікальними, значення можуть повторюватися |\n" +
                "| Порядок елементів       | Зберігається                 | Не гарантовано (за винятком LinkedHashSet) | Зберігається тільки порядок за ключами |\n" +
                "| Доступ до елементів     | За індексом                 | Немає індексації            | За ключем                       |\n" +
                "| Типи елементів          | Лише значення               | Лише значення               | Пара \"ключ-значення\"           |\n\n" +
                "6. Підсумок\n" +
                "Списки, множини і карти — це основні типи колекцій в Java, кожен з яких має свої особливості і застосування. Списки корисні, коли важливо зберігати порядок елементів і дозволяти дублікати, множини — коли потрібно забезпечити унікальність елементів, а карти — коли потрібен швидкий доступ до значень за ключами.");
    }
    public static void setTextOfTopic_11(TextArea textArea){
        textArea.setText("Тема: Обробка виключень\n\n" +
                "1. Що таке виключення?\n\n" +
                "Виключення — це події, які виникають під час виконання програми, що можуть порушити нормальний хід виконання. Виключення може бути спричинене різними помилками, наприклад, діленням на нуль, зверненням до неіснуючого файлу чи втратою з'єднання з базою даних.\n\n" +
                "2. Механізм обробки виключень у Java\n\n" +
                "Java надає механізм обробки виключень, що дозволяє ефективно реагувати на непередбачені помилки та запобігати аварійному завершенню програми. В основі обробки лежить конструкція `try-catch`, яка дає змогу 'ловити' виключення та вжити необхідних заходів для його обробки.\n\n" +
                "3. Ключові слова:\n\n" +
                "* **try**: блок коду, в якому може виникнути виключення.\n" +
                "* **catch**: блок, який перехоплює виключення та обробляє його.\n" +
                "* **finally**: блок, який виконується незалежно від того, чи виникло виключення, чи ні. Зазвичай використовується для очищення ресурсів, таких як закриття файлів або баз даних.\n" +
                "* **throw**: оператор для явного викидання виключення.\n" +
                "* **throws**: використовується в оголошенні методу для вказівки, що метод може викидати певні виключення.\n\n" +
                "4. Приклад обробки виключень:\n\n" +
                "public class ExceptionHandlingExample {\n" +
                "    public static void main(String[] args) {\n" +
                "        try {\n" +
                "            int result = divide(10, 0);  // Спроба поділу на нуль\n" +
                "            System.out.println('Результат: ' + result);\n" +
                "        } catch (ArithmeticException e) {\n" +
                "            System.out.println('Помилка: ' + e.getMessage());  // Обробка виключення\n" +
                "        } finally {\n" +
                "            System.out.println('Цей блок виконується завжди.');\n" +
                "        }\n" +
                "    }\n" +
                "    public static int divide(int a, int b) {\n" +
                "        return a / b;  // Може викликати ArithmeticException\n" +
                "    }\n" +
                "}\n\n" +
                "5. Види виключень:\n\n" +
                "* **Перевизначені виключення (checked exceptions)**: Це виключення, які потрібно обробляти або оголошувати в сигнатурі методу. Наприклад, `IOException`, `SQLException`.\n" +
                "* **Неперевизначені виключення (unchecked exceptions)**: Це виключення, які не обов'язково обробляти або оголошувати в сигнатурі методу. Вони є підкласами `RuntimeException`, наприклад, `NullPointerException`, `ArrayIndexOutOfBoundsException`.\n\n" +
                "6. Користування оператором `throw`:\n\n" +
                "Використовується для явного викидання виключення в програмі:\n\n" +
                "public class ThrowExample {\n" +
                "    public static void main(String[] args) {\n" +
                "        try {\n" +
                "            checkAge(15);  // Викидаємо виключення\n" +
                "        } catch (IllegalArgumentException e) {\n" +
                "            System.out.println('Помилка: ' + e.getMessage());\n" +
                "        }\n" +
                "    }\n" +
                "    public static void checkAge(int age) {\n" +
                "        if (age < 18) {\n" +
                "            throw new IllegalArgumentException('Вік повинен бути не менше 18 років.');\n" +
                "        }\n" +
                "        System.out.println('Вік прийнятний.');\n" +
                "    }\n" +
                "}\n\n" +
                "7. Користування оператором `throws`:\n\n" +
                "Оператор `throws` використовується в сигнатурі методу для оголошення, що метод може викидати виключення.\n\n" +
                "import java.io.*;\n" +
                "public class ThrowsExample {\n" +
                "    public static void main(String[] args) {\n" +
                "        try {\n" +
                "            readFile('non_existent_file.txt');  // Спроба читати неіснуючий файл\n" +
                "        } catch (IOException e) {\n" +
                "            System.out.println('Помилка при читанні файлу: ' + e.getMessage());\n" +
                "        }\n" +
                "    }\n" +
                "    public static void readFile(String fileName) throws IOException {\n" +
                "        FileReader file = new FileReader(fileName);  // Може викликати IOException\n" +
                "        BufferedReader fileInput = new BufferedReader(file);\n" +
                "        System.out.println(fileInput.readLine());\n" +
                "    }\n" +
                "}\n\n" +
                "8. Підсумок:\n\n" +
                "Обробка виключень — це важлива частина програмування в Java, яка дозволяє ефективно керувати помилками і забезпечувати надійність програм. Використовуючи блоки `try-catch`, можна обробляти непередбачені ситуації, а також забезпечити коректну роботу програми навіть у випадку виникнення помилок.");

    }


}
